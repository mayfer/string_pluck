<!DOCTYPE html>
<html>

<head>
    <title>string theory, the guitar kind</title>
    <meta charset='utf-8' />
    <link rel="shortcut icon" href="#">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@mayfer">
    <meta name="twitter:title" content="string simulator">
    <meta name="twitter:description"
        content="This is an interactive string simulator that uses basic Fourier math to generate audio & visuals according to where on the string you pluck from. The audio math is done on the GPU in WebGL">
    <meta name="twitter:image" content="https://i.imgur.com/DvnQIif.png">

    <!-- libs -->
    <script type='text/javascript' src='jquery.min.js?1'></script>
    <script type='text/javascript' src='unmute.js?1'></script>
    <script type='text/javascript' src='draw.js?1'></script>
    <script type='text/javascript' src='notes.js?1'></script>
    <script type='text/javascript' src='audio_shader.js?1'></script>
    <script type='text/javascript' src='plucker.js?1'></script>
    <script type='text/javascript' src='tonejs_midi.js?1'></script>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: black;
            font-family: "San Francisco", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            overflow: hidden;
            width: 100%;
            height: 100%;
            touch-action: manipulation;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            text-align: center;
            color: #888;
            pointer-events: none;
        }

        .container {
            height: 100%;
            margin: 0 auto;
            display: flex;
            /* establish flex container */
            flex-direction: column;
            /* make main axis vertical */
            justify-content: center;
            /* center items vertically, in this case */
            align-items: center;
            /* center items horizontally, in this case */

            /* prevent selection of text */
            user-select: none;

        }

        #draw {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            zoom: 0.8;
        }
        

        #controls .controls-bottom-left {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            padding: 10px;
        }
        #controls .controls-bottom-left-flex {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
        }

        #controls .controls-top-left {
            position: absolute;
            top: 0;
            left: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        #controls .controls-top-right {
            position: absolute;
            top: 0;
            right: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        #controls .spacer {
            display: inline-block;
            width: 30px;
        }


        #controls .strings-menu {
            margin: 0;
            padding: 0;
        }

        #controls .strings-menu .item {
            font-size: 20px;
            line-height: 40px;
            margin: 5px;
            color: #666;
            background: rgba(255, 255, 255, 0.1);
        }
        #controls .strings-menu .item:hover {
            color: #fff;
        }

        #controls .item {
            padding: 0 10px;
            background: #fff;
            color: #000;
            cursor: pointer;
            margin: 5px 10px;
            line-height: 28px;
            font-size: 16px;
            pointer-events: all;
            border-radius: 5px;
            display: flex;
            flex-direction: row;
            align-items: center;
            min-width: 30px;
            text-align: center;
            display: inline-block;
        }

        #controls .track-item {
            padding: 5px 10px;
            /* background: rgba(255, 255, 255, 0.7); */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            color: #fff;
            text-shadow: 0 0px 10px rgba(255, 255, 255, 1), 0 0px 1px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            margin: 2px;
            line-height: 28px;
            font-size: 16px;
            pointer-events: all;
            border-radius: 5px;
            display: inline-block;
            position: relative;
        }
        #controls .track-item.featured:before {
            content: '⭐️ ';
            position: absolute;
            left: -15px;
            top: 5px;
            text-shadow: 0 0 2px black;
        }
        #controls .track-item.featured {
            /* background: linear-gradient(100deg, white, lightgrey); */
            border: 1px solid rgb(255, 255, 255, 0.3);
            margin: 1px;
            font-weight: bold;
        }
        #controls .track-item:hover {
            box-shadow: 0 0px 2px rgba(255, 255, 255, 1);
        }

        #controls .pick-midi-track {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            grid-gap: 10px; 
        }
        #controls .track-artist {
            padding: 5px;
            margin: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            


        }
        #controls .track-artist h3 {
            margin: 5px;
            color: #fffacd;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }

        #controls .section {
            pointer-events: all;
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        #controls .item:active {
            background: #000;
            color: #fff;
        }

        #controls .item.inactive {
            opacity: 0;
            pointer-events: none;
        }

        #controls .gap {
            flex: 1;
        }

        #controls .icon {
            font-size: 12px;
            display: inline-block;
            margin-left: 5px;
            border-radius: 2px;
            background: #7c7c7c22;
            padding: 2px;
        }

        #controls .item.toggle {
            background: #333;
            color: #fff;
            font-size: 25px;
            min-width: 40px;
            line-height: 40px;
            margin: 5px;
            padding: 4px;
        }

        #controls .item.toggle .infotoggle {
            filter: brightness(0) invert(1);
        }
        #controls .item.toggle .choice {
            background: none;
            color: #aaa;
            display: inline-block;
            margin: 0 2px;
            padding: 0 7px;
            background: #ffffff11;
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
            font-size: 20px;
        }

        #controls .item.toggle .choice:hover {
            color: #fff;
        }

        #controls .item.toggle .choice.selected {
            background: #fff;
            color: #000;
            transition: all 0.05s ease-in-out;
        }

        #controls .item.toggle .choice.draw-mode {
            background: #afa;
        }

        #controls .item.toggle .choice:active {}

        #presets {
            background: rgba(0, 0, 0, 0.5);
            margin: 5px;
            color: #fff;
            pointer-events: all;
            border-radius: 5px;
            padding: 10px;
        }

        .presets-list {
            grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
            grid-gap: 3px;
            display: grid;

        }
        .presets-list .track-item.user-preset {
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        #presets .track-item {
            background: rgba(255, 255, 255, 0.1);
            text-shadow: 0 0px 2px rgba(0, 0, 0, 0); 
        }
        #presets .track-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        #presets .preset:hover {
            background: #fff;
        }

        #presets .preset-name {
            font-size: 20px;
            font-weight: bold;
        }

        #presets .preset-description {
            font-size: 12px;
        }

        #presets .preset-button {
            background: #000;
            color: #fff;
            padding: 5px;
            margin-top: 10px;
        }

        #presets .close {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            width: 340px;
            padding: 20px;
            margin: 0;
        }

        .speed-slider {
            appearance: none;
            color: #fff;
            border: 1px solid #fff;
            background: #000;
            border-radius: 5px;
            height: 20px;
        }
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        .speed-slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        .speed-slider::-ms-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        .speed-reset:hover {
            cursor: pointer;
            color: #fff;
            text-decoration: line-through;
        }


        #midi-player {
            color: #aaa;
        }

        .main-menu-modal {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 70px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;

            pointer-events: all;

            overflow-y: auto;
        }

        .info-panel {
            position: fixed;
            font-size: 20px;
            z-index: 100;
            top: 70px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;

            pointer-events: all;

            overflow-y: auto;
        }
        .info-panel .info-inner {
            max-width: 800px;
            margin: 0 auto;
        }
        .info-panel ul li, .info-panel ol li {
            margin-bottom: 5px;
        }

        .main-menu-modal h2 {
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            margin: 10px 0;
            padding: 0;
        }

        @media only screen and (max-width: 800px) {
            #controls {
                /* zoom: 0.6; */
            }

            #controls .controls-inner {
                padding: 5px;
            }

            #controls .item.toggle {
                padding: 2px;
            }

            #controls .icon {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class='container'>
        <div id='draw'></div>
        <div id="controls"></div>
    </div>
    <script type="module">
        import { html, render, Component } from "./preact.htm.module.js"


        function smoothTransition(x, x_start, x_end, start_value, end_value) {
            const scaledX = (x - x_start) / (x_end - x_start) * 10 - 5;
            const sigmoid = 1 / (1 + Math.exp(-scaledX));
            return start_value + (end_value - start_value) * sigmoid;
        }
        window.smoothTransition = smoothTransition;
            
        const base_freq = Notes.note_to_freq('E2');

        const CanvasModes = {
            pluck: 'pluck',
            draw: 'draw',
            erase: 'erase',
            move: 'move',
        }
        window.CanvasModes = CanvasModes;
        window.canvas_mode = CanvasModes.pluck;

        let draw_start = null
        let draw_end = null

        jQuery.event.special.touchstart = {
            setup: function (_, ns, handle) {
                this.addEventListener("touchstart", handle, { passive: false });
            }
        };
        jQuery.event.special.touchmove = {
            setup: function (_, ns, handle) {
                this.addEventListener("touchmove", handle, { passive: false });
            }
        };
        jQuery.event.special.wheel = {
            setup: function (_, ns, handle) {
                this.addEventListener("wheel", handle, { passive: false });
            }
        };
        jQuery.event.special.mousewheel = {
            setup: function (_, ns, handle) {
                this.addEventListener("mousewheel", handle, { passive: false });
            }
        };

        let midi_string_map = {};
        let midi_number_a1 = 33;

        let pluckableStrings = [];

        let width_base_freq;



        function string_width_to_freq(string_width, width_base_freq) {
            if (string_width == 0) {
                return 0;
            }
            return Math.round(base_freq * width_base_freq / string_width);
        }
        function freq_to_string_width(freq, width_base_freq) {
            if (freq == 0) {
                return 0;
            }
            return base_freq * width_base_freq / freq;
        }


        const getMidiNumberFromFreq = (freq) => {
            return Math.round(12 * Math.log2(freq / 440) + 69);
        }
        const getFreqFromMidiNumber = (midi_number) => {
            return 440 * Math.pow(2, (midi_number - 69) / 12);
        }


        const getInitialStrings = (canvas_jq) => {
            let num_strings = 56

            let initial_strings = JSON.parse(localStorage.getItem('strings')) || [];

            if (!initial_strings.length) {
                return getChordStrings(canvas_jq);
            }

            return initial_strings;
        }

        const get72strings = (canvas_jq) => {
            let num_strings = 72;
            let initial_strings = [];
            let width = canvas_jq.width();
            let height = canvas_jq.height();
            for (var i = 0; i < num_strings; i++) {
                initial_strings.push({
                    string_center: { x: canvas_jq.width() / 2, y: 100 + (i + 1) * ((height - 200) / num_strings) },
                    string_width: Notes.relative_note(width_base_freq, -i) * 2,
                    freq: string_width_to_freq(Notes.relative_note(width_base_freq, -i) * 2, width_base_freq),
                    angle: 0, // i * Math.PI / 64
                });
            }

            return initial_strings;
        }

        const getTwoFullOctaveStrings = (canvas_jq) => {
            let num_strings = 24;
            let initial_strings = [];
            let width = canvas_jq.width();
            let height = canvas_jq.height();
            for (var i = 0; i < num_strings; i ++) {
                initial_strings.push({
                    string_center: { x: canvas_jq.width() / 2, y: 100 + (i + 1) * ((height - 200) / num_strings) },
                    string_width: Notes.relative_note(width_base_freq , -(i)),
                    freq: width_base_freq  / Math.pow(2, i / 12),
                    angle: 0, // i * Math.PI / 64
                });
            }

            return initial_strings;

        }

        const getSpiralingStrings = (canvas_jq) => {
            // for(var i=0; i<=40; i++) {
            //     initial_strings.push({
            //         string_center: {x: canvas_jq.width()/2 + canvas_jq.width()/4, y: 100 + (i+1) * 15},
            //         string_width: Notes.relative_note(440, -i*1) * 1,
            //         angle: 0, // i * Math.PI / 64
            //     });
            // }
            // for(var i=0; i<=40; i++) {
            //     initial_strings.push({
            //         string_center: {x: canvas_jq.width()/2 - canvas_jq.width()/4, y: 100 + (i+1) * 15},
            //         string_width: Notes.relative_note(440, -i*1) * 1,
            //         angle: 0, // i * Math.PI / 64
            //     });
            // }
            let num_strings = 72
            const initial_strings = [];

            let width = canvas_jq.width();
            let height = canvas_jq.height();
            const total_angle = Math.PI * 2;
            for (var i = 0; i < num_strings; i++) {
                initial_strings.push({
                    string_center: {
                        x: (width / 3) * Math.sin((total_angle * i / num_strings)) + width / 2,
                        y: (height / 3) * Math.cos((total_angle * i / num_strings)) + height / 2,
                    },
                    // string_center: {x: width/2, y: 100 + (i+1) * ((height-200) / num_strings)},
                    //string_width: Notes.relative_note(width_base_freq, -(i % 24 + 12*Math.floor(i/24))) * 1.2 ,
                    string_width: Notes.relative_note(width_base_freq * 2, -i),
                    freq: width_base_freq * 2 / Math.pow(2, i / 12),
                    angle: Math.PI * (3 / 4) + i * total_angle / num_strings,
                });
            }

            return initial_strings;
        }

        const getAndalusianCadence = (canvas_jq) => {
            let width = canvas_jq.width();
            let height = canvas_jq.height();
            const midi_notes = [
                // A minor (Am): A3 (57), E4 (64), A4 (69), C4 (60)
                57, 64, 69, 60,
                0,
                // G Major (G): G3 (55), D4 (62), G4 (67), B3 (59)
                55, 62, 67, 59,
                0,
                // F Major (F): F3 (53), C4 (60), F4 (65), A3 (57)
                53, 60, 65, 57,
                0,
                // E Major (E): E3 (52), B3 (59), E4 (64), G#3 (56)
                52, 59, 64, 56,
                0,
                // D minor (Dm): D3 (50), A3 (57), D4 (62), F4 (65)
                50, 57, 62, 65,
                0,
                // E Major (E): E3 (52), B3 (59), E4 (64), G#3 (56)
                52, 59, 64, 56
            ];

            const initial_strings = [];

            const num_chords = midi_notes.filter(n => n == 0).length + 1;
            const chunksize = 5;
            const max_vertical = (height - 200) / 50;
            const columns = 2
            const rows = 3

            let note_i = 0;
            for (var i = 0; i < columns; i++) {
                for (var j = 0; j < rows; j++) {
                    const x = 100 + i * (width - 200) / columns;
                    const y = 100 + j * (height - 200) / rows;
                    const w = (width - 200) / columns;
                    const h = (height - 200) / rows;

                    console.log(x, y, w, h);

                    for (var k = 0; k < chunksize; k++) {
                        const midi_number = midi_notes[note_i];
                        note_i++;
                        if (midi_number == 0) continue;

                        const center = (width / columns / 4) * (i / columns) + x + w / 2;
                        const top = (height / rows / 4) * (j / rows) + y + h / 2 + (k - chunksize / 2) * h / chunksize;

                        const note_offset = midi_number - midi_number_a1;
                        initial_strings.push({
                            string_center: { x: center, y: top },
                            //string_width: Notes.relative_note(width_base_freq, -(i % 24 + 12*Math.floor(i/24))) * 1.2 ,
                            string_width: Notes.relative_note(width_base_freq * 2, -note_offset),
                            freq: getFreqFromMidiNumber(midi_number),
                            angle: 0, // i * Math.PI / 64
                            midi_number,
                        });
                    }
                }
            }

            return initial_strings;
        }

        
        const getCanonChordStrings = (canvas_jq) => {

            let width = canvas_jq.width();
            let height = canvas_jq.height();
            const midi_notes = [
                // D Major (D): D4 (62), A4 (69), D5 (74), F#4 (66)
                62, 69, 74, 66,
                0,
                // A Major (A): A3 (57), E4 (64), A4 (69), C#4 (61)
                57, 64, 69, 61,
                0,
                // B minor (Bm): B3 (59), F#4 (66), B4 (71), D4 (62)
                59, 66, 71, 62,
                0,
                // F# minor (F#m): F#3 (54), C#4 (61), F#4 (66), A3 (57)
                54, 61, 66, 57,
                0,
                // G Major (G): G3 (55), D4 (62), G4 (67), B3 (59)
                55, 62, 67, 59,
                0,
                // D Major (D): D3 (50), A3 (57), D4 (62), F#3 (54)
                50, 57, 62, 54,
                0,
                // G Major (G): G3 (55), D4 (62), G4 (67), B3 (59)
                55, 62, 67, 59,
                0,
                // A Major (A): A3 (57), E4 (64), A4 (69), C#4 (61)
                57, 64, 69, 61
            ];
            const initial_strings = [];

            const num_chords = midi_notes.filter(n => n == 0).length + 1;
            const chunksize = 5;
            const max_vertical = (height - 200) / 50;
            const columns = 3
            const rows = 3


            const start_y = height / 15;

            let note_i = 0;
            for (var i = 0; i < columns; i++) {
                for (var j = 0; j < rows; j++) {
                    const x = start_y + i * (width - start_y*2) / columns;
                    const y = start_y + j * (height - start_y*2) / rows;
                    const w = (width - start_y*2) / columns;
                    const h = (height - start_y*2) / rows;

                    console.log(x, y, w, h);

                    for (var k = 0; k < chunksize; k++) {
                        const midi_number = midi_notes[note_i];
                        note_i++;
                        if (midi_number == 0) continue;

                        const center = (width / columns / 4) * (i / columns) + x + w / 2;
                        const top = (height / rows / 4) * (j / rows) + y + h / 2 + (k - chunksize / 2) * h / chunksize;

                        const note_offset = midi_number - midi_number_a1;
                        initial_strings.push({
                            string_center: { x: center, y: top },
                            //string_width: Notes.relative_note(width_base_freq, -(i % 24 + 12*Math.floor(i/24))) * 1.2 ,
                            string_width: Notes.relative_note(width_base_freq * 2, -note_offset),
                            freq: getFreqFromMidiNumber(midi_number),
                            angle: 0, // i * Math.PI / 64
                            midi_number,
                        });
                    }
                }
            }

            return initial_strings;
        }

        

        const getChordStrings = (canvas_jq) => {

            let width = canvas_jq.width();
            let height = canvas_jq.height();
            // C, G, Am, F chords
            const midi_notes = [
                // C major
                48,
                52,
                55,
                60,
                64,

                0,
                // G major
                55,
                59,
                62,
                67,
                71,
                0,
                // A minor
                57,
                60,
                64,
                69,
                72,

                0,
                // F major
                53,
                57,
                60,
                65,
                69,

                0,

            ]
            const initial_strings = [];

            const num_chords = midi_notes.filter(n => n == 0).length + 1;
            const chunksize = 6;
            const max_vertical = (height - 200) / 50;
            const columns = 2
            const rows = 2

            let note_i = 0;
            for (var i = 0; i < columns; i++) {
                for (var j = 0; j < rows; j++) {
                    const x = 100 + i * (width - 200) / columns;
                    const y = 100 + j * (height - 200) / rows;
                    const w = (width - 200) / columns;
                    const h = (height - 200) / rows;

                    console.log(x, y, w, h);

                    for (var k = 0; k < chunksize; k++) {
                        const midi_number = midi_notes[note_i];
                        note_i++;
                        if (midi_number == 0) continue;

                        const center = (width / columns / 4) * (i / columns) + x + w / 2;
                        const top = (height / rows / 4) * (j / rows) + y + h / 2 + (k - chunksize / 2) * h / chunksize;

                        const note_offset = midi_number - midi_number_a1;
                        initial_strings.push({
                            string_center: { x: center, y: top },
                            //string_width: Notes.relative_note(width_base_freq, -(i % 24 + 12*Math.floor(i/24))) * 1.2 ,
                            string_width: Notes.relative_note(width_base_freq * 2, -note_offset),
                            freq: getFreqFromMidiNumber(midi_number),
                            angle: 0, // i * Math.PI / 64
                            midi_number,
                        });
                    }
                }
            }

            return initial_strings;
        }

        const getMidiNoteStrings = (canvas_jq, midi_numbers) => { 

            let filled_in_midi_numbers = [];
            let min_midi_number = undefined;
            let max_midi_number = undefined;
            for(let i=0; i<midi_numbers.length; i++) {
                if(min_midi_number === undefined) {
                    min_midi_number = midi_numbers[i];
                }
                if(max_midi_number === undefined) {
                    max_midi_number = midi_numbers[i];
                }
                min_midi_number = Math.min(min_midi_number, midi_numbers[i]);
                max_midi_number = Math.max(max_midi_number, midi_numbers[i]);
            }
            for(let i=min_midi_number; i<=max_midi_number; i++) {
                filled_in_midi_numbers.push(i);
            }

            let width = canvas_jq.width();
            let height = canvas_jq.height();
            const initial_strings = [];
            const start_y = height / 15;
            for(var i=0; i<filled_in_midi_numbers.length; i++) {
                const midi_number = filled_in_midi_numbers[i];
                if (midi_number == 0) continue;

                const center = width / 2;
                const top = start_y + (i + 1) * ((height - start_y*2) / filled_in_midi_numbers.length);

                const note_offset = midi_number - midi_number_a1;
                initial_strings.push({
                    string_center: { x: center, y: top },
                    //string_width: Notes.relative_note(width_base_freq, -(i % 24 + 12*Math.floor(i/24))) * 1.2 ,
                    string_width: Notes.relative_note(width_base_freq * 2, -note_offset),
                    freq: getFreqFromMidiNumber(midi_number),
                    angle: 0,
                    midi_number,
                });
            }

            return initial_strings;
        }


        const resetAndAddStrings = async function (canvas_jq, strings, options = { skip_audio: false }) {
            let width = canvas_jq.width();
            let height = canvas_jq.height();

            let duration = 5000;

            const num_strings = strings.length;
            const num_overtones = 12;

            if (options.skip_audio) {
                // console.log('skipping audio')
            } else {
                if (window.audioShader) {
                    await window.audioShader.destroy();
                    window.audioShader = null;
                }
                window.audioShader = new AudioShader(num_strings, num_overtones);
                window.audioShader.setup_audio();
            }

            pluckableStrings.length = 0;

            midi_string_map = {};

            for (let i = 0; i < strings.length; i++) {
                const string = strings[i];
                const overtones = [];
                if ((!string.string_width && !string.freq) || !string.string_center) {
                    console.error('string_width or freq or string_center missing', i, string);
                    continue;
                }
                let freq = string.freq ? parseInt(string.freq) : parseInt(base_freq * width_base_freq / string.string_width);
                let string_width = freq_to_string_width(freq, width_base_freq);

                for (let j = 0; j < num_overtones; j++) {
                    overtones.push({ freq: (j + 1) * freq, amplitude: 1 });
                }
                const midi_number = getMidiNumberFromFreq(freq);
                let { note, error } = Notes.freq_to_note(freq);

                let string_center = string.string_center;
                if(string.screen) {
                    string_center.x = width * string.string_center.x / string.screen.width;
                    string_center.y = height * string.string_center.y / string.screen.height;
                }

                var drawWave = new pluckableString({
                    id: i,
                    canvas: canvas_jq.get(0),
                    freq,
                    midi_number,
                    note,
                    note_micro_offset: error,
                    overtones,
                    wave_height: 50,
                    string_width,
                    string_center,
                    angle: string.angle,
                    duration,
                    audio: window.audioShader,
                    string_slack: Math.min(20, Math.max(8, 10000/string.freq)),
                    screen: { width, height },
                })
                pluckableStrings.push(drawWave);
                midi_string_map[midi_number] = drawWave;
                string.screen = { width, height };
                if(!string.freq) {
                    string.freq = freq;
                }
            }

            pluckableStrings.forEach(s => s.draw_still());

            window.NOTE_FONT = Math.min(15, parseInt(height / pluckableStrings.length)) + "px Arial";

            window.dispatchEvent(new CustomEvent('strings_loaded', { detail: { strings: pluckableStrings } }));

            localStorage.setItem('strings', JSON.stringify(strings));

        }
        window.snap_to_note = true;
        $(document).ready(function () {
            // on blur, go into idle
            // on focus, resume
            window.idle = false;
            $(window).focus(function () {
                window.idle = false;
            });
            // create a drawing area inside an element

            var canvas_jq = new Canvas($('#draw').empty());


            let canvas_offset = canvas_jq.offset();
            let width = canvas_jq.width();
            let height = canvas_jq.height();
            let resize_timeout;
            $(window).resize(function () {
                if(resize_timeout) {
                    clearTimeout(resize_timeout);
                }
                resize_timeout = setTimeout(() => {
                    setCanvasSize(canvas_jq, window.innerWidth, window.innerHeight);
                    const old_width_base_freq = width_base_freq;
                    const old_width = width;
                    const old_height = height;

                    width = canvas_jq.width();
                    height = canvas_jq.height();
                    // reset and add strings

                    width_base_freq = Math.min(width * 0.95, 1000);

                    // resetAndAddStrings(canvas_jq, pluckableStrings.map(s => { return { string_center: s.string_center, string_width: s.string_width, angle: s.angle, freq: s.freq, screen: s.screen } }), { skip_audio: true });
                    for(let string of pluckableStrings) {
                        string.screen = { width, height };
                        string.string_width = string.string_width * width / old_width;
                        string.string_center.x = string.string_center.x * width / old_width;
                        string.string_center.y = string.string_center.y * height / old_height;
                        string.string_position.x = string.string_center.x - string.string_width / 2;
                        string.string_position.y = string.string_center.y;
                    }
                }, 100)
            });

            width_base_freq = Math.min(width * 0.95, 1000);

            const initial_strings = getInitialStrings(canvas_jq);

            var canvas = canvas_jq.get(0);
            var context = canvas.getContext("2d");

            const fill_styles_per_mode = {
                [CanvasModes.pluck]: "rgba(0, 0, 0, 1.0)",
                [CanvasModes.draw]: "rgba(0, 50, 0, 1.0)",
                [CanvasModes.erase]: "rgba(50, 0, 0, 1.0)",
                [CanvasModes.move]: "rgba(0, 0, 50, 1.0)",
            }
            context.fillStyle = "rgba(0, 0, 0, 1.0)";
            context.lineWidth = 2;
            context.strokeStyle = "#fff";

            resetAndAddStrings(canvas_jq, initial_strings);


            function start_drawing() {
                window.canvas_mode = CanvasModes.draw;
            }
            function stop_drawing() {
                window.canvas_mode = CanvasModes.pluck;
                finish_drawing_string({restart_audio: true});
            }

            function finish_drawing_string({restart_audio = false} = {}) {
                let newStrings = pluckableStrings.map(s => { return { string_center: s.string_center, string_width: s.string_width, angle: s.angle } });

                if (window.canvas_mode == CanvasModes.draw && draw_start) {
                    let offsetStart = draw_start;
                    let offsetEnd = draw_end;
                    let string_center = { x: offsetStart.x + (offsetEnd.x - offsetStart.x) / 2, y: offsetStart.y + (offsetEnd.y - offsetStart.y) / 2 };

                    let string_width = Math.sqrt(Math.pow(offsetEnd.x - offsetStart.x, 2) + Math.pow(offsetEnd.y - offsetStart.y, 2))

                    let freq = string_width_to_freq(string_width, width_base_freq);

                    if (window.snap_to_note) {
                        let snap_freq = Notes.note_to_freq(Notes.freq_to_note(freq).note);
                        string_width = freq_to_string_width(snap_freq, width_base_freq);
                        freq = snap_freq;
                    }

                    let string = {
                        string_center,
                        string_width,
                        freq,
                        angle: Math.atan2(offsetEnd.y - offsetStart.y, offsetEnd.x - offsetStart.x),
                        screen: { width, height },
                    }

                    newStrings.push(string);
                }

                resetAndAddStrings(canvas_jq, newStrings, { skip_audio: !restart_audio });
            }

            function finish_erasing_string() {
                const erase_distance = 10;

                if (window.canvas_mode == CanvasModes.erase && draw_start) {
                    let offsetStart = draw_start;
                    let offsetEnd = draw_end;

                    const distance = Math.sqrt(Math.pow(offsetEnd.x - offsetStart.x, 2) + Math.pow(offsetEnd.y - offsetStart.y, 2));
                    const num_hops = Math.ceil(distance / erase_distance);

                    const string_ids_to_erase = [];
                    for (let i = 0; i < num_hops; i++) {
                        const offsetX = offsetStart.x + (offsetEnd.x - offsetStart.x) * i / num_hops;
                        const offsetY = offsetStart.y + (offsetEnd.y - offsetStart.y) * i / num_hops;

                        for (let j = 0; j < pluckableStrings.length; j++) {
                            const string = pluckableStrings[j];


                            const angledOffset = rotate_coordinates_for_string(string, offsetX, offsetY);
                            const angledOffsetX = angledOffset.x;
                            const angledOffsetY = angledOffset.y;

                            if (angledOffset.x > string.string_position.x && angledOffset.x < string.string_position.x + string.string_width && angledOffset.y > string.string_position.y - erase_distance && angledOffset.y < string.string_position.y + erase_distance) {
                                string_ids_to_erase.push(j);
                            }
                        }
                    }
                    let newStrings = pluckableStrings.filter((s, i) => !string_ids_to_erase.includes(i)).map(s => { return { string_center: s.string_center, string_width: s.string_width, angle: s.angle } });

                    if (newStrings.length < pluckableStrings.length) {
                        resetAndAddStrings(canvas_jq, newStrings, { skip_audio: window.canvas_mode != CanvasModes.pluck });
                    }
                }

            }

            let moving_string;
            let moving_string_edge;
            const move_grab_distance = 20;
            canvas_jq.on('mousedown touchstart', (e) => {
                e.preventDefault();

                if (window.canvas_mode == CanvasModes.draw || window.canvas_mode == CanvasModes.erase) {
                    const { offsetX, offsetY } = click_or_touch_coordinates(e);
                    draw_start = { x: offsetX, y: offsetY };
                    draw_end = { x: offsetX, y: offsetY };
                } else if (window.canvas_mode == CanvasModes.move) {
                    const { offsetX, offsetY } = click_or_touch_coordinates(e);
                    draw_start = { x: offsetX, y: offsetY };
                    draw_end = { x: offsetX, y: offsetY };

                    // if cursor is on a string, set it as moving
                    for(let string of pluckableStrings) {
                        const angledOffset = rotate_coordinates_for_string(string, offsetX, offsetY);
                        if(angledOffset.x > string.string_position.x - move_grab_distance && angledOffset.x < string.string_position.x + string.string_width + move_grab_distance && angledOffset.y > string.string_position.y - move_grab_distance && angledOffset.y < string.string_position.y + move_grab_distance) {
                            moving_string = string;
                            moving_string.moving = true;
                            // if cursor is near the ends of the string
                            if(Math.abs(angledOffset.x - string.string_position.x) < move_grab_distance) {
                                moving_string_edge = 'left';
                                // console.log('left', angledOffset.x, string.string_position.x)
                            } else if(Math.abs(angledOffset.x - (string.string_position.x + string.string_width)) < move_grab_distance) {
                                moving_string_edge = 'right';
                                // console.log('right', angledOffset.x, string.string_position.x + string.string_width)
                            }
                            window.hovered_string = string;
                        }
                    }
                }
            })
            canvas_jq.on('mouseup touchend touchcancel', (e) => {
                e.preventDefault();
                if (draw_start) {
                    if (window.canvas_mode == CanvasModes.draw) {
                        finish_drawing_string();
                    } else if (window.canvas_mode == CanvasModes.erase) {
                        finish_erasing_string();
                    } else if (window.canvas_mode == CanvasModes.move) {
                        if(moving_string) {
                            moving_string.moving = false;
                            moving_string = undefined;
                            // resetAndAddStrings(canvas_jq, pluckableStrings.map(s => { return { string_center: s.string_center, string_width: s.string_width, angle: s.angle, freq: s.freq } }), { skip_audio: true });
                        }
                        moving_string = undefined;
                        moving_string_edge = undefined;
                    }
                    draw_start = null
                    draw_end = null
                }
                window.hovered_string = undefined;
            })
            $(document).on('mousemove touchmove', (e) => {
                if (draw_start) {
                    if ((window.canvas_mode == CanvasModes.draw || window.canvas_mode == CanvasModes.erase)) {
                        const offset = click_or_touch_coordinates(e);
                        draw_end.y = offset.offsetY;
                        draw_end.x = offset.offsetX;
                    } else if (window.canvas_mode == CanvasModes.move) {
                        const offset = click_or_touch_coordinates(e);
                        draw_end.y = offset.offsetY;
                        draw_end.x = offset.offsetX;
                        if(moving_string) {
                            const moved_x = draw_end.x - draw_start.x;
                            const moved_y = draw_end.y - draw_start.y;
                            if(moving_string_edge == 'left' || moving_string_edge == 'right') {
                                const angle_drawend_to_string_center = Math.atan2(draw_end.y - moving_string.string_center.y, draw_end.x - moving_string.string_center.x)
                                moving_string.angle = angle_drawend_to_string_center - (moving_string_edge == 'left' ? Math.PI : 0);
                            } else {
                                moving_string.string_center.x += moved_x;
                                moving_string.string_center.y += moved_y;

                                moving_string.string_position.x = moving_string.string_center.x - moving_string.string_width / 2;
                                moving_string.string_position.y = moving_string.string_center.y;
                            }
                        }
                        draw_start.x = draw_end.x;
                        draw_start.y = draw_end.y;
                    }
                    
                } else if (window.canvas_mode == CanvasModes.move) {
                    // window.hovered_string = undefined;
                    const offset = click_or_touch_coordinates(e);
                    let new_hover = false;
                    for(let string of pluckableStrings) {
                        const angledOffset = rotate_coordinates_for_string(string, offset.offsetX, offset.offsetY);
                        if(angledOffset.x > string.string_position.x - move_grab_distance && angledOffset.x < string.string_position.x + string.string_width + move_grab_distance && angledOffset.y > string.string_position.y - move_grab_distance && angledOffset.y < string.string_position.y + move_grab_distance) {
                            if(window.hovered_string) {
                                const hoveredStringAngledOffset = rotate_coordinates_for_string(window.hovered_string, offset.offsetX, offset.offsetY);
                                const distance1 = Math.abs(hoveredStringAngledOffset.y - window.hovered_string.string_position.y)
                                const distance2 = Math.abs(angledOffset.y - string.string_position.y)
                                if(distance1 >= distance2) {
                                    // dont change hovered string
                                    window.hovered_string = string;
                                    new_hover = true;
                                }
                            } else {
                                window.hovered_string = string;
                                new_hover = true;
                            }
                        }   
                    }
                    if(!new_hover) {
                        window.hovered_string = undefined;
                    }
                }
            })



            let start_time;
            let note_index = 0;
            let pluck_index = 0;
            let midi_track;
            let notes;
            window.midi_paused = true

            let speed = 1;
            let pluck_duration = 0.350;

            let notes_map = {}
            let notes_map_cursors = {}

            let last_frame_time_ms = Date.now();
            let note_last_frame_ms = Date.now();
            let midi_progress_time = 0;
            let note_time_current = 0;

            async function set_remote_midi_track(url) {
                console.log('fetching midi', url);
                let midi_file = await fetch(url).then(r => r.arrayBuffer());
                // sate to blob
                let midi_blob = new Blob([midi_file], { type: 'audio/midi' });
                // create a URL for the blob
                let midi_url = URL.createObjectURL(midi_blob);
                // use tonejs to load the midi file
                let midi_json = await Midi.fromUrl(midi_url);


                midi_json.name = url.replace('./midis/', '').replace('.mid', '').replace('/', ': ');

                // console.log(midi_json);
                // set_midi_track(midi_json);
                return midi_json;
            }

            function set_midi_track(new_midi_track) {
                window.midi_paused = true;
                start_time = Date.now();
                note_last_frame_ms = Date.now();
                note_time_current = 0;

                // reset all current plucks
                pluckableStrings.forEach(s => {
                    s.reset_pluck_offsets()
                    s.stop_sound()
                });

                console.log('playing midi track', new_midi_track);
                if(new_midi_track.header.ticksPerBeat) {
                    speed = 1 / (new_midi_track.header.ticksPerBeat / 480);
                    console.log('speed', speed, new_midi_track.header.ticksPerBeat);
                }

                note_index = 0;
                midi_track = new_midi_track;
                notes = [];
                notes_map = {}
                notes_map_cursors = {}

                midi_track.tracks.forEach((t, i) => {
                    t.notes.forEach(n => {
                        if(n.midi) {
                            notes.push(n);
                        }
                    })
                })
                notes.sort((a, b) => a.time - b.time);

                
                notes.forEach(note => {
                    note.time += 1; // leave time for pluck
                    if (!notes_map[note.midi]) {
                        notes_map[note.midi] = [];
                        notes_map_cursors[note.midi] = 0;
                    }
                    notes_map[note.midi].push(note);
                })

                for(let note_key in notes_map) {
                    let prev_note = undefined;
                    for(let i=0; i<notes_map[note_key].length; i++) {
                        let note = notes_map[note_key][i];
                        if(prev_note && note.time - prev_note.time < 0.05) {
                            notes_map[note_key][i] = undefined;
                        }
                        prev_note = note;
                    }
                    notes_map[note_key] = notes_map[note_key].filter(n => n);
                }
                notes = Object.values(notes_map).flat();
                notes.sort((a, b) => a.time - b.time);

                // check if all velocities are the same, and set them to random if so
                let velocities_obj = {};
                notes.map(n => velocities_obj[n.velocity.toString()] = n.velocity);
                if(Object.keys(velocities_obj).length < 3) {
                    console.log('most notes have same velocity of', velocities_obj)
                    notes.forEach(n => n.velocity =  0.3 + Math.random() * 0.7)   
                }

                const midi_strings = getMidiNoteStrings(canvas_jq, Object.keys(notes_map)); 
                // check if every existing string matches the new midi strings
                if(!midi_strings.every(s => pluckableStrings.some(p => p.string_widthfreq == s.freq))) {
                    resetAndAddStrings(canvas_jq, midi_strings, {skip_audio: false});
                }

                if(window.midi_start_timer) {
                    clearTimeout(window.midi_start_timer);
                }
                window.midi_start_timer = setTimeout(() => {
                    window.midi_paused = false;
                    start_time = Date.now();
                    note_last_frame_ms = Date.now();
                    note_time_current = 0;

                    const midi_length_seconds = Math.max(...notes.map(n => n.time));
                    const midi_track_name = midi_track.name;
                    window.midi_paused = false;
                    const event = new CustomEvent('midi_loaded', { detail: { midi_length_seconds: midi_length_seconds , midi_track_name: midi_track_name } });
                    window.dispatchEvent(event);
                }, 100)
            };

            let frame = () => {
                requestAnimationFrame(frame)
                if (window.idle) {
                    return;
                }
                if (last_frame_time_ms && Date.now() - last_frame_time_ms > 3000) {
                    note_last_frame_ms = last_frame_time_ms;
                    if(window.midi_paused == false) {
                        window.midi_paused = true
                        console.log('pausing due to inactivity?')
                    }
                }

                let one_sec_ms = 1000;

                context.fillStyle = fill_styles_per_mode[window.canvas_mode];

                context.fillRect(0, 0, context.width, context.height);

                
                // pluckableStrings.forEach(s => {
                    //     if (s.playing) s.draw()
                    //     else if (s.plucking) s.draw_pluck();
                    //     else s.draw_still();
                    // });
                
                // draw non-plucking strings first:
                pluckableStrings.forEach(s => {
                    if(!s.plucking) {
                        if (!s.playing) s.draw_still();
                    }
                });
                const timeOrderedPluckableStrings = pluckableStrings.filter(s => !s.plucking).sort((a, b) => {
//let progress = (this.duration - this.time_diff) / this.duration;
                    // sort by playing strings last, which are then ordered by progress property
                    if(!a.playing && !b.playing) {
                        return 0;
                    }
                    if(a.playing && !b.playing) {
                        return 1;
                    } else if(!a.playing && b.playing) {
                        return -1;
                    }
                    const progress_a = a.duration - a.time_diff;
                    const progress_b = b.duration - b.time_diff;
                    return progress_a - progress_b;
                })
                timeOrderedPluckableStrings.forEach(s => {
                    if(!s.plucking) {
                        if (s.playing) s.draw()
                    }
                });
                pluckableStrings.forEach(s => {
                    if (s.plucking) s.draw_pluck();
                });
                    


                if (!start_time) {
                    start_time = Date.now();
                }
                let note_time_diff = ((Date.now() - note_last_frame_ms)/1000) * speed;

                // if(!document.hasFocus()) {
                //     window.midi_paused = true;
                // }
                if (!window.midi_paused) {
                    Object.keys(notes_map_cursors).forEach(midi_num => {
                        let cursor = notes_map_cursors[midi_num];
                        let note = notes_map[midi_num][cursor];
                        if (note) {
                            let plucking_string = midi_string_map[note.midi]
                            if (plucking_string) {
                                const prev_note = notes_map[midi_num][cursor - 1];
                                const time_since_prev_note = prev_note ? note.time - prev_note.time : undefined;
                                // if(time_since_prev_note !== undefined && time_since_prev_note < 0.001) {
                                //     console.log('skipping playing note', note.time, prev_note.time);
                                //     return;
                                // }
                                const _pluck_duration = time_since_prev_note ? Math.min(pluck_duration, Math.max(0.05, time_since_prev_note / 6)) : pluck_duration;

                                // let pluck_time = Math.max((plucking_string.prev_note_time || 0) + 50, note.time * one_sec_ms - _pluck_duration);
                                let pluck_time = Math.max((plucking_string.prev_note_time || 0), note.time - _pluck_duration);

                                if (note_time_current >= pluck_time) {
                                    const velocity_based_x_offset = Math.max(0, Math.min(0.95, note.velocity ? Math.pow(note.velocity, 0.6) : 1)) * plucking_string.string_width / 2

                                    const a = 12 / 440; // Scale factor
                                    const b = -6; // Shift to center the sigmoid at the midpoint of 440 and 880
                                    const high_freq_damping = smoothTransition(plucking_string.freq, 330, 880, 1, 0.5);
                                    // const low_freq_damping = smoothTransition(plucking_string.freq, 30, 170, 0.5, 1);
                                    // console.log(plucking_string.freq, high_freq_damping);

                                    let offsetX = plucking_string.string_center.x + velocity_based_x_offset * high_freq_damping;

                                    let progress = _pluck_duration > 0 ? (note_time_current - pluck_time) / _pluck_duration : 0.5;
                                    let velocity = Math.min(0.99, note.velocity ? note.velocity*2 : 1);
                                    let offsetY = plucking_string.string_center.y + Math.min(
                                        plucking_string.string_slack-1, progress * Math.pow(velocity, 1.5) * plucking_string.string_slack
                                    );
                                    plucking_string.set_pluck_offsets(offsetX, offsetY);
                                }
                            }
                        }
                    })
                    note_time_current += note_time_diff;

                    let note = notes[note_index];
                    let string = midi_string_map[note.midi];

                    if (note_time_current >= note.time) {
                        if (string) {
                            string.pluck();
                            string.prev_note_time = note.time;
                        }
                        note_index++;
                        notes_map_cursors[note.midi]++

                        if (note_index >= notes.length) {
                            window.midi_paused = true;
                        }
                    }
                    note_last_frame_ms = Date.now();
                }

                last_frame_time_ms = Date.now();

                if ((window.canvas_mode == CanvasModes.draw || window.canvas_mode == CanvasModes.erase) && draw_start && draw_end) {
                    let string_width = Math.sqrt(Math.pow(draw_end.x - draw_start.x, 2) + Math.pow(draw_end.y - draw_start.y, 2))
                    if (string_width > 0) {
                        if (window.canvas_mode == CanvasModes.draw) {
                            context.strokeStyle = "#ffa";
                        } else if (window.canvas_mode == CanvasModes.erase) {
                            context.strokeStyle = "#f00";
                        }
                        context.beginPath();
                        context.moveTo(draw_start.x, draw_start.y);
                        context.lineTo(draw_end.x, draw_end.y);
                        context.stroke();

                        const label_finger_offset = {
                            x: -10,
                            y: -50,
                        }

                        if (draw_end.y < 100) {
                            label_finger_offset.y = 50;
                        }

                        if (window.canvas_mode == CanvasModes.draw) {
                            let freq = string_width_to_freq(string_width, width_base_freq);
                            let { note, error } = Notes.freq_to_note(freq);
                            context.save();
                            context.fillStyle = "#fff";
                            context.font = "20px Arial";
                            context.fillText(note, draw_end.x + label_finger_offset.x, draw_end.y + label_finger_offset.y);

                            if (!window.snap_to_note) {
                                context.font = "10px Arial"
                                context.fillText((error < 0 ? '-' : error > 0 ? '+' : '') + error.toFixed(2) + 'hz', draw_end.x + label_finger_offset.x, draw_end.y + label_finger_offset.y + 10);
                            }
                            context.restore();
                        }
                        if (window.canvas_mode == CanvasModes.erase) {
                            context.save();
                            context.fillStyle = "#f00";
                            context.font = "20px Arial";
                            context.fillText("Erase", draw_end.x - 30, draw_end.y + label_finger_offset.y);
                            context.restore();
                        }
                    }


                }


                /*
                for (let coordinate of Object.values(touchInstances)) {
                    // draw circle where touch is if in pluck mode
                    if (window.canvas_mode == CanvasModes.pluck) {
                        context.save();
                        context.beginPath();
                        context.arc(coordinate.x, coordinate.y, 5, 0, 2 * Math.PI, false);
                        context.fillStyle = '#ffffff44';
                        context.fill();
                        context.restore();
                    }
                }
                */
            }


            let touchInstances = {};

            setTimeout(() => {
                window.started = true
            }, 100)
            frame();


            function click_or_touch_coordinates(e) {
                let x, y;
                if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
                    var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                    x = touch.pageX;
                    y = touch.pageY;
                } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover' || e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
                    x = e.clientX;
                    y = e.clientY;
                }

                let offsetX = Math.min(Math.max(x - canvas_jq.offset().left, 10), canvas_jq.width() - 10)
                let offsetY = Math.min(Math.max(y - canvas_jq.offset().top, 1), canvas_jq.height())
                return { offsetX, offsetY };
            }

            let always_pluck = false;
            let prev_cursor;

            $(window).blur(function () {
                //strings.forEach(s => s.stop_sound());
                //init()
                touchInstances = {};
            });
            $(document).on('mouseout', function (event) {
                if (!event.relatedTarget) {
                    touchInstances = {};
                }
            });


            let auto_pluck_distance = 5;

            let rotate_coordinates_for_string = function (string, offsetX, offsetY) {
                return {
                    x: string.string_center.x + (offsetX - string.string_center.x) * Math.cos(-string.angle) - (offsetY - string.string_center.y) * Math.sin(-string.angle),
                    y: string.string_center.y + (offsetX - string.string_center.x) * Math.sin(-string.angle) + (offsetY - string.string_center.y) * Math.cos(-string.angle),
                }
            }

            let cursor_move_handler = function (touch) {
                const { id, x, y, prevX, prevY, startX, startY } = touch;
                const offsetX = x;
                const offsetY = y;


                pluckableStrings.forEach(string => {
                    const angledOffset = rotate_coordinates_for_string(string, offsetX, offsetY);
                    const angledOffsetX = angledOffset.x;
                    const angledOffsetY = angledOffset.y;
                    const prevAngledOffset = rotate_coordinates_for_string(string, prevX, prevY);
                    const prevAngledOffsetX = prevAngledOffset.x;
                    const prevAngledOffsetY = prevAngledOffset.y;
                    if (string.hand_plucking && string.pluck_source.id === id) {
                        string.set_pluck_offsets(angledOffsetX, angledOffsetY)
                    } else {
                        if (always_pluck) {
                            // if prev->current line crosses string
                            if((angledOffsetY - string.string_center.y) * (prevAngledOffsetY - string.string_center.y) <= 0 && angledOffsetX > string.string_center.x - string.string_width/2 && angledOffsetX < string.string_center.x + string.string_width/2) {
                                if(!string.hand_plucking) {
                                    string.hand_plucking = true;
                                    string.pluck_source = touch;
                                    string.stop_sound()
                                }
                                string.set_pluck_offsets(angledOffsetX, angledOffsetY);
                            }
                        }
                        // if (always_pluck) {
                        //     if (angledOffset.x > string.string_position.x && angledOffset.x < string.string_position.x + string.string_width && angledOffset.y > string.string_position.y - auto_pluck_distance && angledOffset.y < string.string_position.y + auto_pluck_distance) {

                        //         if (string.hand_plucking) {
                        //             string.set_pluck_offsets(angledOffsetX, angledOffsetY)
                        //         } else {
                        //             string.set_pluck_offsets(angledOffsetX, angledOffsetY);
                        //             string.hand_plucking = true;
                        //             string.pluck_source = touch;
                        //             string.stop_sound()
                        //         }

                        //     }
                        // }
                    }
                });
            }

            let idle_timeout;

            window.idle = false;
            function handleClickOrTouchEvents(event) {

                if (idle_timeout) {
                    clearTimeout(idle_timeout);
                    window.idle = false;
                }
                idle_timeout = setTimeout(() => {
                    if (window.midi_paused) {
                        window.idle = true;
                    }
                }, 15000);


                if (window.canvas_mode !== CanvasModes.pluck) {
                    return;
                }
                if (!window.started) {
                    return
                }
                event.preventDefault();
                event.stopPropagation();
                let eventType;
                let coordinates;

                if ((event.type == "click" ||event.type === 'touchstart' || event.type === 'mousedown')) { 
                    if(window.audioShader) {
                        window.audioShader.resume();
                    } else {
                        console.log('no audio shader', window.audioShader)
                    }
                }

                switch (event.type) {
                    case 'touchstart':
                    case 'touchmove':
                    case 'touchend':
                    case 'touchcancel':
                        eventType = 'touch';
                        coordinates = Array.from(event.changedTouches).map(touch => {
                            const x = touch.clientX;
                            const y = touch.clientY;
                            let offsetX = Math.min(Math.max(x - canvas_offset.left, 10), width - 10)
                            let offsetY = Math.min(Math.max(y - canvas_offset.top, 1), height)
                            return { id: touch.identifier, x, y }
                        });
                        break;
                    case 'mousedown':
                    case 'mousemove':
                    case 'mouseup':
                        eventType = 'mouse';
                        coordinates = [{ id: 'mouse', x: event.clientX, y: event.clientY }];
                        break;
                    default:
                        return;
                }

                for (const coordinate of coordinates) {
                    const touch = touchInstances[coordinate.id];

                    if (event.type === 'touchend' || event.type === 'mouseup' || event.type === 'touchcancel') {
                        if (touch) {
                            touch.end = true;
                        }
                    } else {
                        if (!touch) {
                            touchInstances[coordinate.id] = {
                                id: coordinate.id,
                                prevX: coordinate.x,
                                prevY: coordinate.y,
                                x: coordinate.x,
                                y: coordinate.y,
                                startX: coordinate.x,
                                startY: coordinate.y,
                            };
                        } else {
                            touch.prevX = touch.x;
                            touch.prevY = touch.y;
                            touch.x = coordinate.x;
                            touch.y = coordinate.y;
                        }
                    }
                }

                if (event.type === 'touchstart' || event.type === 'mousedown') {
                    always_pluck = true;
                    Object.values(touchInstances).filter(ti => ti.x & ti.y).forEach(touch => {
                        cursor_move_handler(touch);
                    })
                }
                if (event.type === 'touchend' || event.type === 'mouseup' || event.type === 'touchcancel') {
                    Object.values(touchInstances).filter(ti => ti.end).forEach(touch => {
                        pluckableStrings.forEach(string => {
                            if (string.hand_plucking && string.pluck_source && string.pluck_source.id === touch.id) {

                                const angledOffset = rotate_coordinates_for_string(string, touch.prevX, touch.prevY);
                                string.pluck(angledOffset.x, angledOffset.y);
                            }
                        });
                        delete touchInstances[touch.id];
                    })

                    if (Object.values(touchInstances).length === 0) {
                        always_pluck = false;
                    }
                }
                if (event.type === 'touchmove' || event.type === 'mousemove') {

                    Object.values(touchInstances).filter(ti => ti.x && ti.y).forEach(touch => {
                        const { x, y } = touch;
                        const prev_cursor = touch.prevX && touch.prevY ? { x: touch.prevX, y: touch.prevY } : undefined;
                        if (prev_cursor) {
                            let distance = Math.sqrt(Math.pow(x - prev_cursor.x, 2) + Math.pow(y - prev_cursor.y, 2));
                        }
                        cursor_move_handler(touch);
                    })
                }

            }

            ['touchstart', 'touchmove', 'touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup'].forEach(eventName => {
                canvas.addEventListener(eventName, handleClickOrTouchEvents, { passive: false });
            });

            const pick_svg = html`<svg style="width: 20px;height: 15px;" xmlns="http://www.w3.org/2000/svg" version="1.0" viewBox="0 0 1079.000000 1280.000000" preserveAspectRatio="xMidYMid meet">
<metadata>
Created by potrace 1.15, written by Peter Selinger 2001-2017
</metadata>
<g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="#000000" stroke="none">
<path d="M4830 12794 c-935 -43 -1710 -175 -2430 -414 -733 -243 -1301 -570 -1720 -990 -400 -400 -620 -857 -671 -1390 -15 -160 1 -536 32 -775 80 -608 384 -1553 856 -2660 909 -2132 2275 -4560 3245 -5774 436 -544 765 -812 970 -788 401 48 1423 1247 2635 3092 1645 2505 2917 5066 2998 6035 3 41 14 131 23 200 26 191 23 516 -7 683 -66 378 -206 687 -459 1017 -87 113 -350 374 -487 484 -137 109 -410 292 -575 384 -863 481 -1994 781 -3310 877 -200 15 -923 27 -1100 19z"/>
</g>
</svg>`

            function hashStringToRGBA(str) {
                // Hash function to convert string to a numerical value
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                }

                // Generate RGBA values
                const r = (hash >> 24) & 0xFF;
                const g = (hash >> 16) & 0xFF;
                const b = (hash >> 8) & 0xFF;
                const a = 0.3;

                return `rgba(${r}, ${g}, ${b}, ${a})`;
            }


            const DivCustomClick = (props) => {
                const { onClick, ...rest } = props;

                const handleMouseDown = (event) => {
                    if (onClick) onClick(event);
                    event.preventDefault();
                };

                const handleTouchStart = (event) => {
                    if (onClick) onClick(event);
                    event.preventDefault();
                };

                return html`
                    <div
                        ...${rest}
                        onMouseDown=${handleMouseDown}
                        onTouchStart=${handleTouchStart}
                    />
                `;
            };

            class Controls extends Component {
                constructor() {
                    super();
                    this.state = {
                        canvas_mode: window.canvas_mode,
                        snap_to_note: window.snap_to_note,
                        show_presets: false,
                        show_midi_player: true,
                        midis: [],
                        speed: 50,
                        midi_progress_percentage: 0,
                        midi_length_seconds: 0,
                    }
                }
                componentDidMount() {
                    window.addEventListener('keydown', (e) => {
                        // if (e.shiftKey) {
                        //     start_drawing();
                        //     this.setState({ canvas_mode: CanvasModes.draw });
                        // }
                    })
                    const exitDrawingIfDrawMode = () => {
                        if (window.canvas_mode == CanvasModes.draw) {
                            finish_drawing_string();
                            stop_drawing();
                            this.setState({ canvas_mode: CanvasModes.pluck });
                        }
                    }
                    window.addEventListener('keyup', (e) => {
                        // exitDrawingIfDrawMode();
                    })
                    window.addEventListener('visibilitychange', (e) => {
                        exitDrawingIfDrawMode();
                        // resume audio
                        if(window.audioShader) window.audioShader.resume();

                        if(e.visibilityState == 'hidden') {
                            window.midi_paused = true;
                            this.setState({ playing: false });
                        }
                    })
                    window.addEventListener('blur', () => {
                        exitDrawingIfDrawMode();
                    })
                    window.addEventListener('focus', () => {
                        exitDrawingIfDrawMode();
                    })
                    window.addEventListener('midi_loaded', (e) => {
                        this.setState({ midi_length_seconds: e.detail.midi_length_seconds, midi_track_name: e.detail.midi_track_name });
                    })
                    window.addEventListener('strings_loaded', (e) => {
                        this.setState({ show_main_menu: false });
                    })

                    // load midi list from midis/midis.json
                    fetch('midis/midis.json').then(r => r.json()).then(midis => {
                        // midis is object with folder as key
                        const new_midis = Object.keys(midis).map(folder => {
                            return midis[folder].map(midi => {
                                return `${folder}/${midi}`
                            })
                        }).flat();
                        this.setState({ midis: new_midis });
                    })
                }


                render() {
                    const touch_device = 'ontouchstart' in document.documentElement;
                    const preset_slugs = JSON.parse(localStorage.getItem('preset_slugs')) || [];
                    const presets = preset_slugs.map(slug => JSON.parse(localStorage.getItem('preset:' + slug)));
                    const { canvas_mode, show_modes, show_main_menu, show_info } = this.state;

                    const grouped_midis = this.state.midis.reduce((acc, cur) => {
                        const folder = cur.split('/')[0];
                        if(!acc[folder]) {
                            acc[folder] = [];
                        }
                        acc[folder].push(cur);
                        return acc;
                    }, {});

                    return html`
                            <div class='controls-top-right'>
                                ${this.state.playing ? html`
                                    <div class='section' id='midi-player'>
                                        ${this.state.playing ? html`
                                            <div class='midi-progress-bar'>
                                                <span class='midi-progress-bar-fill' style='width: ${this.state.midi_progress_percentage}%'></span>
                                                ${' '}${this.state.midi_track_name} [${Math.round(this.state.midi_length_seconds / 60)}:${Math.round(this.state.midi_length_seconds % 60).toString().padStart(2, '0')}]
                                                ${' '}
                                            </div>
                                        ` : html``}
                                        <span class='spacer'></span>
                                        <input type='range' class='speed-slider' min='0' max='100' value='${this.state.speed}' oninput=${(e) => {
                                            // cast 0:100 to 0.1:10
                                            const val = (e.target.value < 50) ? (0.5 + e.target.value/100) : 2*(e.target.value-50) / 100 + 1;
                                            this.setState({ speed: e.target.value});
                                            speed = val;
                                        }} />
                                        <span class='speed-reset' onClick=${e => {
                                            this.setState({speed: 50})
                                            speed = 1;
                                        }}>${(speed).toFixed(2)}x speed</span>
                                        <span class='spacer'></span>
                                        <div class='item' onClick=${async () => {
                                            if(!this.state.playing) {
                                                const midi_file = this.state.selected_midi;
                                                const midi_json = await set_remote_midi_track("./midis/" + midi_file);
                                                set_midi_track(midi_json);
                                                this.setState({ playing: true });
                                            } else {
                                                this.setState({ playing: false });
                                                // stop plucking all strings
                                                pluckableStrings.forEach(s => s.reset_pluck_offsets());
                                                window.midi_paused = true;
                                            }
                                        }}>
                                            ${this.state.playing ? "⏹ Stop" : "▶️ Play"}
                                        </div>
                                    </div>
                                ` : html``}
                                <!--
                                    <div class='item' onClick=${() => {
                                        this.setState({ show_midi_player: !this.state.show_midi_player });
                                    }}>
                                        ${this.state.show_midi_player ? 'Hide' : '🎵 MIDI Player'}
                                    </div>
                                -->
                            </div>

                            <div class='controls-top-left'>
                                <${DivCustomClick} class='item toggle ${show_info ? '' : ''}' onClick=${() => {
                                        
                                        this.setState({ show_info: !show_info });
                                    }}>
                                        ${show_modes ? `ⓧ` : html`<span class='infotoggle'>❓</span>`}
                                </${DivCustomClick}>

                                ${show_info ? html`
                                    <div class='info-panel'>
                                        <div class='info-inner'>
                                            <h1>Pluck</h1>
                                            <h3>by Murat</h3>
                                            <p>This is a math-based string simulator. </p>
                                            <p>Both the audio and visuals are generated using the same math, rendered at different speeds so the eye can see. No tricks or audio files are used: everything is calculated from raw sine waves.</p>
                                            <ul>
                                                <li>The vibrations are modeled based on how far down the string you pluck from.  </li>
                                                <li>The velocity of midi notes are mapped to both pluck position, as well as pluck strength. </li>
                                            </ul>
                                            <p>
                                                This YouTube video of a slow motion string pluck proves that our simulated result is very close to reality.
                                                <br />
                                                <iframe width="350" height="180" style="margin: 10px;" src="https://www.youtube.com/embed/LNNQvG0jWtw?si=DZa9TS3TdcURpwbF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                                            </p>
                                            <p>
                                                Technical details:
                                                <ul>
                                                    <li>Each string is simulated with 12 overtones (integer multiples of the note frequency) </li>
                                                    <li>To calculate amplitude of each overtone, we take the Fourier transform of the plucked string at the time the pick is released </li>
                                                    <li>Higher frequency overtones decay faster than lower frequency overtones </li>
                                                    <li>72 strings ⅹ 12 overtones ⅹ 44,100 samples per second = 52,920,000 calculations per second </li>
                                                    <li>Audio buffer of 1024 samples are sent to the GPU to compute in parallel on each tick</li>
                                                </ul>
                                            </p>
                                            <p>
                                                There are several directions I can take this project from here:
                                                <ol>
                                                    <li>Turn it into an interactive educational tool to teach physics of sound & music. </li>
                                                    <li>Turn it into a music learning tool for kids where songs are pre-made as chords that the user can pluck to learn rhythm and feel. </li>
                                                    <li>Turn it into an interactive art installation</li> 
                                                    <li>Turn it into a game where i.e. a bouncing ball plucks the strings & you try to place strings to match a melody idk</li>
                                                </ol>
                                                If you are interested in any of the above, please get in touch at <a href='mailto:murat@ayfer.net'>murat@ayfer.net</a> or <a href='https://twitter.com/mayfer'>@mayfer</a>.
                                            </p>
                                        </div>

                                    </div>
                                ` : html``}
                            </div>

                            
                            <div class='controls-bottom-left'>

                                ${show_modes ? html`
                                    <div class='strings-menu'>
                                        <div class='item' onClick=${() => {
                                            resetAndAddStrings(canvas_jq, []);
                                        }}>
                                            🧹 Clear all
                                        </div>
                                        <br />
                                        <div class='item' onClick=${() => {
                                            const name = prompt('Save preset as');
                                            // convert name to slug
                                            const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-$/, '').replace(/^-/, '');
                                            // save to localstorage
                                            const preset_slugs = JSON.parse(localStorage.getItem('preset_slugs')) || [];
                                            if (preset_slugs.includes(slug)) {
                                                const overwrite = confirm('Overwrite existing preset?');
                                                if (!overwrite) {
                                                    return;
                                                }
                                            }
                                            preset_slugs.push(slug);
                                            const screen = { width, height };
                                            console.log('screen', screen);
                                            localStorage.setItem('preset_slugs', JSON.stringify(preset_slugs));
                                            localStorage.setItem('preset:' + slug, JSON.stringify({ name, slug, strings: pluckableStrings.map(s => { return { string_center: s.string_center, freq: s.freq, string_width: s.string_width, angle: s.angle, screen } }) }));

                                            this.setState({ trigger_rerender: Date.now() });
                                        }}>
                                            💾 Save
                                        </div>
                                    </div>
                                ` : html``}
                                      
                                <div class='controls-bottom-left-flex'>
                                    <${DivCustomClick} class='item toggle ${show_modes ? '' : ''}' onClick=${() => {
                                            if(show_modes && this.state.canvas_mode != CanvasModes.pluck) {
                                                // enter pluck mode
                                                if(this.state.canvas_mode == CanvasModes.draw) {
                                                    stop_drawing();
                                                }
                                                this.setState({ canvas_mode: CanvasModes.pluck });
                                                window.canvas_mode = CanvasModes.pluck;
                                            }
                                            this.setState({ show_modes: !show_modes });
                                        }}>
                                            ${show_modes ? `ⓧ` : `✏️`}
                                    </${DivCustomClick}>

                                    ${show_modes ? html`
                                        <div class='draw-mode-button item toggle'>
                                            <span class='choice ${canvas_mode == CanvasModes.pluck ? 'selected' : ''}' onClick=${() => {
                                    this.setState({ canvas_mode: CanvasModes.pluck });
                                    window.canvas_mode = CanvasModes.pluck;
                                    stop_drawing();
                                }}>
                                                ${pick_svg} Pluck
                                            </span>
                                            <span class='choice ${canvas_mode == CanvasModes.draw ? 'selected' : ''}' onClick=${() => {
                                    this.setState({ canvas_mode: CanvasModes.draw });
                                    window.canvas_mode = CanvasModes.draw;
                                    start_drawing();
                                }}>
                                                ✏️ Draw
                                            </span>
                                            <span class='choice ${canvas_mode == CanvasModes.erase ? 'selected' : ''}' onClick=${() => {
                                    this.setState({ canvas_mode: CanvasModes.erase });
                                    window.canvas_mode = CanvasModes.erase;
                                    // start_drawing();
                                }}>
                                                🧽 Erase
                                            </span>
                                            <span class='choice ${canvas_mode == CanvasModes.move ? 'selected' : ''}' onClick=${() => {
                                                this.setState({ canvas_mode: CanvasModes.move });
                                                window.canvas_mode = CanvasModes.move;
                                                // start_drawing();
                                            }}>
                                                ☛ Move
                                            </span>
                                        </div>

                                        <div class='item toggle ${canvas_mode == CanvasModes.draw ? '' : 'inactive'}' onClick=${() => {
                                        this.setState({ snap_to_note: !this.state.snap_to_note });
                                        window.snap_to_note = !this.state.snap_to_note;
                                        }}>
                                            <span class='choice ${this.state.snap_to_note ? 'selected' : ''}'>Snap to note</span>
                                            <span class='choice ${this.state.snap_to_note ? '' : 'selected'}'>Precise</span>
                                        </div>
                                    ` : html`
                                    `}
                                    <div class='gap'></div>


                                    <${DivCustomClick} class='item toggle ${show_main_menu ? '' : ''}' onClick=${() => {
                                            this.setState({ show_main_menu: !show_main_menu });
                                        }}>
                                            ${show_main_menu ? `ⓧ` : `♫`}
                                    </${DivCustomClick}>
                                </div>
                            </div>

                            ${show_main_menu ? html`
                                <div class='main-menu-modal'>

                                    <h2>String presets</h2>
                                    <div id='presets'>
                                        <div class='presets-list'>

                                            <div class='track-item' onClick=${() => {
                                                resetAndAddStrings(canvas_jq, get72strings(canvas_jq));
                                            }}>
                                                <div class='preset-name'>72 strings</div>
                                            </div>

                                            <div class='track-item' onClick=${() => {
                                                resetAndAddStrings(canvas_jq, getSpiralingStrings(canvas_jq));
                                            }}>
                                                <div class='preset-name'>Spiral harp</div>
                                            </div>

                                            <div class='track-item' onClick=${() => {
                                                resetAndAddStrings(canvas_jq, getTwoFullOctaveStrings(canvas_jq));
                                            }}>
                                                <div class='preset-name'>2 octaves</div>
                                            </div>

                                            <div class='track-item' onClick=${() => {
                                                resetAndAddStrings(canvas_jq, getChordStrings(canvas_jq));
                                            }}>
                                                <div class='preset-name'>I–V–vi–IV Chords</div>
                                            </div>


                                            <div class='track-item' onClick=${() => {
                                                resetAndAddStrings(canvas_jq, getCanonChordStrings(canvas_jq));
                                            }}>
                                                <div class='preset-name'>Canon Chords</div>
                                            </div>

                                            <div class='track-item' onClick=${() => {
                                                resetAndAddStrings(canvas_jq, getAndalusianCadence(canvas_jq));
                                            }}>
                                                <div class='preset-name'>Andalusian Chords</div>
                                            </div>

                                            ${presets.map(preset => html`
                                                <div class='track-item user-preset' onClick=${() => {
                                                    resetAndAddStrings(canvas_jq, preset.strings);
                                                }}>
                                                    <div class='preset-name'>${preset.name}</div>
                                                </div>
                                            `)}
                                        </div>
                                    </div>

                                    <h2>MIDI tracks</h2>
                                    <div class='pick-midi-track' id='midi-player'>
                                        ${Object.keys(grouped_midis).sort().map(folder => {
                                            // use folder title to seed random color
                                            const color = hashStringToRGBA("salt" + folder);
                                            return html`
                                                <div class='track-artist' style='background: ${color}'>
                                                    <h3>${folder}</h3>
                                                    ${grouped_midis[folder].map(midi => {
                                                        const track_name = midi.split('/').pop().replace(/\.mid$/, '');
                                                        const featured_tracks = [
                                                            'Gymnopedie No. 1',
                                                            'Gymnopedie No. 3',
                                                            'Clair de Lune',
                                                            'Hungarian Rhapsody No. 2',
                                                            'La Campanella',
                                                            'Fugue BWV 578',
                                                            'Moonlight Sonata (3rd movement)',
                                                            'Piano Sonata No. 13',
                                                            'Suite No. 1, Morning Mood',
                                                        ]
                                                        const featured = featured_tracks.includes(track_name);
                                                        return html`
                                                            <div>
                                                            <div class='track-item ${featured ? 'featured' : ''}' onClick=${async e => {
                                                                const midi_file = midi;
                                                                this.setState({ selected_midi: midi_file, show_main_menu: false });

                                                                const midi_json = await set_remote_midi_track("./midis/" + midi_file);
                                                                set_midi_track(midi_json);
                                                                this.setState({ playing: true });
                                                            }}>${track_name}</div>
                                                            </div>
                                                        `
                                                    })}
                                                </div>
                                            `
                                        })}
                                    </div>
                                    <p>The tracks marked with ⭐️ are author's picks.</p>
                                </div>
                            ` : html``}
                        `
                }
            }
            render(html`<${Controls} />`, document.getElementById('controls'))
        });


    </script>
</body>

</html>

<!DOCTYPE html>
<html>
    <head>
        <title>string theory, the guitar kind</title>
        <meta charset='utf-8' />
        <link rel="shortcut icon" href="#">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mayfer">
        <meta name="twitter:title" content="string simulator">
        <meta name="twitter:description" content="This is an interactive string simulator that uses basic Fourier math to generate audio & visuals according to where on the string you pluck from. The audio math is done on the GPU in WebGL">
        <meta name="twitter:image" content="https://i.imgur.com/DvnQIif.png">

        <!-- libs -->
        <script type='text/javascript' src='jquery.min.js?1'></script>
        <script type='text/javascript' src='unmute.js?1'></script>
        <script type='text/javascript' src='draw.js?1'></script>
        <script type='text/javascript' src='notes.js?1'></script>
        <script type='text/javascript' src='audio_shader.js?1'></script>
        <script type='text/javascript' src='plucker.js?1'></script>
        <script type='text/javascript' src='chopin.js?1'></script>
        <script type='text/javascript' src='midi/bach_cello.js'></script>
        <script type='text/javascript' src='midi/canon.js'></script>
        <script type='text/javascript' src='midi/dust.js'></script>
        <script type='text/javascript' src='midi/satie.js'></script>
        <script type='text/javascript' src='midi/harp1.js'></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            html, body { margin: 0; padding: 0; background: black; height:  100%; font-family: sans-serif; }
            .info { position: absolute; top: 10px; left: 0; width: 100%; text-align: center; color: #888; padding: 10px; }
            .container { height: 100%; margin: 0 auto; 
    display: flex;           /* establish flex container */
    flex-direction: column;  /* make main axis vertical */
    justify-content: center; /* center items vertically, in this case */
    align-items: center;     /* center items horizontally, in this case */}
            #draw { width: 100%; height: 100%; }
            #save { margin: 10px; font-size: 20px; line-height: 25px; }

            #buttons { padding: 5%; position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: row; justify-content: center; align-items: center; text-align: center; background: rgba(0, 0, 0, 0.5); }
            .button  { display: inline-block; height: 50px; line-height: 50px; font-size: 40px; cursor: pointer; width: 300px; text-align: center; background: #ddd; color: #000; margin: 10px; }
            .button:hover { background: #fff; }
            #playground-button { background: #ffa; }
            .draw-mode-button { position: absolute; bottom: 10px; left: 10px; padding: 10px; background: #fff; color: #000; cursor: pointer; }
        </style>
        <script type='text/javascript'>
            jQuery.event.special.touchstart = {
                setup: function( _, ns, handle ) {
                    this.addEventListener("touchstart", handle, { passive: false });
                }
            };
            jQuery.event.special.touchmove = {
                setup: function( _, ns, handle ) {
                    this.addEventListener("touchmove", handle, { passive: false });
                }
            };
            jQuery.event.special.wheel = {
                setup: function( _, ns, handle ){
                    this.addEventListener("wheel", handle, { passive: false });
                }
            };
            jQuery.event.special.mousewheel = {
                setup: function( _, ns, handle ){
                    this.addEventListener("mousewheel", handle, { passive: false });
                }
            };

            let midi_string_map = {};
            let midi_number_a1 = 33;
                
            let pluckableStrings = [];

            const getInitialStrings = (canvas_jq) => {
                let num_strings = 56
                let initial_strings = []
                return initial_strings;

                // for(var i=0; i<=40; i++) {
                //     initial_strings.push({
                //         string_center: {x: canvas_jq.width()/2 + canvas_jq.width()/4, y: 100 + (i+1) * 15},
                //         string_width: Notes.relative_note(440, -i*1) * 1,
                //         angle: 0, // i * Math.PI / 64
                //     });
                // }
                // for(var i=0; i<=40; i++) {
                //     initial_strings.push({
                //         string_center: {x: canvas_jq.width()/2 - canvas_jq.width()/4, y: 100 + (i+1) * 15},
                //         string_width: Notes.relative_note(440, -i*1) * 1,
                //         angle: 0, // i * Math.PI / 64
                //     });
                // }

                let width = canvas_jq.width();
                let height = canvas_jq.height();
                let width_55hz = Math.min(width - 100, 500)
                const total_angle = Math.PI * 2;
                for(var i=0; i<num_strings; i++) {
                    initial_strings.push({
                        string_center: {
                            x:  (width/3) * Math.sin((total_angle * i / num_strings)) + width/2,
                            y:  (height/3) * Math.cos((total_angle * i / num_strings)) + height/2,
                        },
                        // string_center: {x: width/2, y: 100 + (i+1) * ((height-200) / num_strings)},
                        //string_width: Notes.relative_note(width_55hz, -(i % 24 + 12*Math.floor(i/24))) * 1.2 ,
                        string_width: Notes.relative_note(width_55hz*2, -i),
                        angle: Math.PI * (3/4) + i * total_angle / num_strings,
                    });
                }

                return initial_strings;
            }
            const resetAndAddStrings = function(canvas_jq, audioShader, strings, options={skip_audio: false}) {
                midi_string_map = {};
                let width = canvas_jq.width();
                let height = canvas_jq.height();
                let width_55hz = Math.min(width - 100, 500)

                let duration = 5000;

                const num_strings = Math.max(strings.length, 10);
                const num_overtones = 12;

                if(!options.skip_audio) {
                    if(audioShader) {
                        audioShader.destroy();
                    }
                    audioShader = new AudioShader(num_strings, num_overtones);
                    audioShader.setup_audio();
                    audioShader.resume();
                }

                pluckableStrings.length = 0;

                for(let i=0; i<strings.length; i++) {
                    const string = strings[i];
                    const overtones = [];
                    const base_freq = 110;
                    let freq = parseInt(base_freq * width_55hz/string.string_width);
                    for(let j=0; j<num_overtones; j++) {
                        overtones.push({freq: (j+1) * freq, amplitude: 1});
                    }
                    var drawWave = new pluckableString({
                        id: i,
                        canvas: canvas_jq.get(0),
                        overtones,
                        wave_height: 50,
                        string_width: string.string_width,
                        string_center: string.string_center,
                        midi_number: string.midi_number,
                        angle: string.angle,
                        duration,
                        audio: audioShader,
                        string_slack: Math.max(5, Math.min(40, string.string_width/5)),
                    })
                    pluckableStrings.push(drawWave);
                    midi_string_map[string.midi_number] = drawWave;
                }

                pluckableStrings.forEach(s => s.draw_still());

                return { audioShader };

            }
            $(document).ready(function() {
                // on blur, go into idle
                // on focus, resume
                window.idle = false;
                $(window).blur(function(){
                    window.idle = true;
                });
                $(window).focus(function(){
                    window.idle = false;
                });
                // create a drawing area inside an element
                var canvas_jq = new Canvas($('#draw'));

                let canvas_offset = canvas_jq.offset();
                let width = canvas_jq.width();
                let height = canvas_jq.height();
                let width_55hz = Math.min(width - 100, 500)

                const initial_strings = getInitialStrings(canvas_jq);

                var canvas = canvas_jq.get(0);
                var context = canvas.getContext("2d");

                context.fillStyle = "rgba(0, 0, 0, 0.5)";
                context.lineWidth = 2;
                context.strokeStyle = "#fff";

                let { audioShader } = resetAndAddStrings(canvas_jq, null, initial_strings);


                let drawing_mode = false;
                let draw_start = null
                let draw_end = null

                // if touch device
                const button = document.createElement('div');
                button.classList.add('draw-mode-button');
                button.innerText = 'Draw mode';
                document.body.appendChild(button);
                $(button).on('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    if(drawing_mode) {
                        stop_drawing();
                    } else {
                        start_drawing();
                    }
                })

                function start_drawing() {
                    drawing_mode = true;
                    button.innerText = 'Stop drawing';
                }
                function stop_drawing() {
                    drawing_mode = false;
                    button.innerText = 'Enter draw mode';
                    finish_drawing_string();
                }

                document.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    if(e.key == " ") {
                        console.log("reset")
                        let { audioShader: newAudioShader } = resetAndAddStrings(canvas_jq, audioShader, []);
                        audioShader = newAudioShader;
                    }
                })

                function finish_drawing_string() {
                    let newStrings = pluckableStrings.map(s => { return {string_center: s.string_center, string_width: s.string_width, angle: s.angle, midi_number: s.midi_number} });

                    if(drawing_mode && draw_start) {
                        let offsetStart = draw_start;
                        let offsetEnd = draw_end;
                        let string_center = {x: offsetStart.x + (offsetEnd.x - offsetStart.x)/2, y: offsetStart.y + (offsetEnd.y - offsetStart.y)/2};

                        const string_width = Math.sqrt(Math.pow(offsetEnd.x - offsetStart.x, 2) + Math.pow(offsetEnd.y - offsetStart.y, 2))
                        let string = {
                            string_center,
                            string_width,
                            angle: Math.atan2(offsetEnd.y - offsetStart.y, offsetEnd.x - offsetStart.x),
                        }

                        newStrings.push(string);
                    }
                    
                    let { audioShader: newAudioShader } = resetAndAddStrings(canvas_jq, audioShader, newStrings, {skip_audio: drawing_mode});
                    audioShader = newAudioShader;
                }

                canvas_jq.on('mousedown touchstart', (e) => {
                    e.preventDefault();

                    if(drawing_mode) {
                        const {offsetX, offsetY} = click_or_touch_coordinates(e);
                        draw_start = {x: offsetX, y: offsetY};
                        draw_end = {x: offsetX, y: offsetY};
                    }
                })
                canvas_jq.on('mouseup touchend', (e) => {
                    e.preventDefault();
                    if(drawing_mode && draw_start) {
                        finish_drawing_string();
                        draw_start = null
                        draw_end = null
                    }
                })
                $(document).on('mousemove touchmove', (e) => {
                    if(drawing_mode && draw_start) {
                        const offset = click_or_touch_coordinates(e);
                        draw_end.y = offset.offsetY;
                        draw_end.x = offset.offsetX;
                    }
                })


                
                let start;
                let note_index = 0;
                let pluck_index = 0;
                let midi_track;
                let notes;
                window.pause = true
                
                let speed = 0.75;
                let pluck_duration = 250;
                
                let notes_map = {}
                let notes_map_cursors = {}

                async function set_remote_midi_track(url) {
                    let midi_json = await fetch(url).then(r => r.json());
                    set_midi_track(midi_json);
                    debugger
                }
                
                function set_midi_track(new_midi_track) {
                    midi_track = new_midi_track;    
                    notes = midi_track.tracks[0].notes;
                    notes_map = {}
                    notes_map_cursors = {}
                    notes.forEach(note => {
                        if(!notes_map[note.midi]) {
                            notes_map[note.midi] = [];
                            notes_map_cursors[note.midi] = 0;
                        }
                        notes_map[note.midi].push(note);
                    })
                };

                let last_frame_time;

                let frame = () => {
                    requestAnimationFrame(frame)
                    if(window.idle) {
                        return;
                    }
                    if(last_frame_time && Date.now() - last_frame_time > 1000) {
                        window.pause = true
                    }
                    last_frame_time = Date.now();

                    let one_sec_ms = 1000 * (1/speed);

                    context.fillRect(0, 0, context.width, context.height);
                    pluckableStrings.forEach(s => {
                        if(s.playing) s.draw()
                        else if(s.plucking) s.draw_pluck();
                        else s.draw_still();
                    });

                    if(!start) {
                        start = Date.now();
                    }
                    let time_diff = Date.now()-start;

                    // if(!document.hasFocus()) {
                    //     window.pause = true;
                    // }
                    if(!window.pause) {
                        Object.keys(notes_map_cursors).forEach(midi_num => {
                            let cursor = notes_map_cursors[midi_num];
                            let note = notes_map[midi_num][cursor];
                            if(note) {
                                let plucking_string = midi_string_map[note.midi]
                                let pluck_time = Math.max((plucking_string.prev_note_time || 0)+50, note.time * one_sec_ms - pluck_duration);
                                if(time_diff >= pluck_time) {
                                    let offsetX = plucking_string.pluck_offset_x ? plucking_string.pluck_offset_x : plucking_string.string_center.x + (Math.random() * 2 - 1)*plucking_string.string_width/2;
                                    let progress = (time_diff - pluck_time) / pluck_duration;
                                    let velocity = note.velocity ? note.velocity : 1;
                                    let offsetY = plucking_string.string_center.y + progress * velocity * plucking_string.string_slack;
                                    plucking_string.set_pluck_offsets(offsetX, offsetY);
                                }
                            }
                        })
                        
                        let note = notes[note_index];
                        let note_time = note.time * one_sec_ms;
                        let string = midi_string_map[note.midi];

                        if(time_diff >= note_time) {
                            if(string) {
                                string.pluck();
                            }
                            note_index++;
                            notes_map_cursors[note.midi]++

                            string.prev_note_time = note_time;
                            if(note_index >= notes.length) {
                                window.pause = true;
                            }
                        }
                    }

                    if(drawing_mode && draw_start && draw_end) {
                        context.strokeStyle = "#ffa";
                        context.beginPath();
                        context.moveTo(draw_start.x, draw_start.y);
                        context.lineTo(draw_end.x, draw_end.y);
                        context.stroke();
                    }
                }

                // prevent pluck on first button
                $('#buttons').on('touchstart mousedown', function (e) {e.stopPropagation();})
                
                const touchInstances = {};
                $("#draw-mode-button").one('mousedown touchstart', function() {

                    setTimeout(() => {
                        window.started = true
                    }, 100)

                    audioShader.resume();
                    frame();
                    $("#buttons").remove()
                })


                function click_or_touch_coordinates(e) {
                    if(e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel'){
                        var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                        x = touch.pageX;
                        y = touch.pageY;
                    } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type=='mouseout' || e.type=='mouseenter' || e.type=='mouseleave') {
                        x = e.clientX;
                        y = e.clientY;
                    }

                    let offsetX = Math.min(Math.max(x - canvas_jq.offset().left, 10), canvas_jq.width()-10)
                    let offsetY = Math.min(Math.max(y - canvas_jq.offset().top, 1), canvas_jq.height())
                    return {offsetX, offsetY};
                }

                let always_pluck = false;
                let prev_cursor;

                $(window).blur(function(){
                    //strings.forEach(s => s.stop_sound());
                    //init()
                });

                let auto_pluck_distance = 5;

                $(document).on('keydown', (e) => {
                    if(e.shiftKey) {
                        start_drawing();
                    }
                })
                $(document).on('keyup', (e) => {
                    if(drawing_mode) {
                        finish_drawing_string();
                        stop_drawing();
                    }
                })

                rotate_coordinates_for_string = function(string, offsetX, offsetY) {
                    return {
                        x: string.string_center.x + (offsetX - string.string_center.x) * Math.cos(-string.angle) - (offsetY - string.string_center.y) * Math.sin(-string.angle),
                        y: string.string_center.y + (offsetX - string.string_center.x) * Math.sin(-string.angle) + (offsetY - string.string_center.y) * Math.cos(-string.angle),
                    }
                }
                function linesIntersect({cursorStart, cursorEnd, stringStart, stringEnd}) {
                    return true
                    const x1 = cursorStart.x;
                    const y1 = cursorStart.y;
                    const x2 = cursorEnd.x;
                    const y2 = cursorEnd.y;
                    const x3 = stringStart.x;
                    const y3 = stringStart.y;
                    const x4 = stringEnd.x;
                    const y4 = stringEnd.y;

                    const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                    if (denominator === 0) return false; // lines are parallel

                    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
                    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

                    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
                }
                
                let cursor_move_handler = function(touch) {
                    const { id, x, y, prevX, prevY, startX, startY } = touch;
                    const offsetX = x;
                    const offsetY = y;


                    pluckableStrings.forEach(string => {
                        const angledOffset = rotate_coordinates_for_string(string, offsetX, offsetY);
                        const angledOffsetX = angledOffset.x;
                        const angledOffsetY = angledOffset.y;
                        if(string.hand_plucking && string.pluck_source.id === id) {
                            string.set_pluck_offsets(angledOffsetX, angledOffsetY)
                        } else {
                            if(always_pluck) {
                                if(angledOffset.x > string.string_position.x && angledOffset.x < string.string_position.x + string.string_width && angledOffset.y > string.string_position.y - auto_pluck_distance && angledOffset.y < string.string_position.y + auto_pluck_distance) {

                                    if(string.hand_plucking) {
                                        string.set_pluck_offsets(angledOffsetX, angledOffsetY)
                                    } else {
                                        string.set_pluck_offsets(angledOffsetX, angledOffsetY);
                                        string.hand_plucking = true;
                                        string.pluck_source = touch;
                                        string.stop_sound()
                                    }
                                
                                }
                            }
                        }
                    });
                }
                
                let idle_timeout;

                window.idle = false;
                function handleClickOrTouchEvents(event) {

                    if(idle_timeout) {
                        clearTimeout(idle_timeout);
                        window.idle = false;
                    }
                    idle_timeout = setTimeout(() => {
                        window.idle = true;
                    }, 3000);


                    if(drawing_mode) {
                        return;
                    }
                    if(!window.started) {
                        return
                    }
                    event.preventDefault();
                    event.stopPropagation();
                    let eventType;
                    let coordinates;

                    switch (event.type) {
                        case 'touchstart':
                        case 'touchmove':
                        case 'touchend':
                            eventType = 'touch';
                            coordinates = Array.from(event.changedTouches).map(touch => {
                                const x = touch.clientX;
                                const y = touch.clientY;
                                let offsetX = Math.min(Math.max(x - canvas_offset.left, 10), width-10)
                                let offsetY = Math.min(Math.max(y - canvas_offset.top, 1), height)
                                return { id: touch.identifier, x, y }
                            });
                            break;
                        case 'mousedown':
                        case 'mousemove':
                        case 'mouseup':
                            eventType = 'mouse';
                            coordinates = [{ id: 'mouse', x: event.clientX, y: event.clientY }];
                            break;
                        default:
                            return;
                    }

                    for (const coordinate of coordinates) {
                        const touch = touchInstances[coordinate.id];

                        if (event.type === 'touchend' || event.type === 'mouseup') {
                            if (touch) {
                                touch.end = true;
                            }
                        } else {
                            if (!touch) {
                                touchInstances[coordinate.id] = {
                                    id: coordinate.id,
                                    prevX: coordinate.x,
                                    prevY: coordinate.y,
                                    x: coordinate.x,
                                    y: coordinate.y,
                                    startX: coordinate.x,
                                    startY: coordinate.y,
                                };
                            } else {
                                touch.prevX = touch.x;
                                touch.prevY = touch.y;
                                touch.x = coordinate.x;
                                touch.y = coordinate.y;
                            }
                        }
                    }

                    if(event.type === 'touchstart' || event.type === 'mousedown') {
                        always_pluck = true;
                        Object.values(touchInstances).filter(ti => ti.x & ti.y).forEach(touch => {
                            const { x, y } = touch;
                            cursor_move_handler(touch);
                        })
                    }
                    if(event.type === 'touchend' || event.type === 'mouseup') {
                        Object.values(touchInstances).filter(ti => ti.end).forEach(touch => {
                            pluckableStrings.forEach(string => {
                                if(string.hand_plucking && string.pluck_source && string.pluck_source.id === touch.id) {
                                    
                                    const angledOffset = rotate_coordinates_for_string(string, touch.prevX, touch.prevY);
                                    string.pluck(angledOffset.x, angledOffset.y);
                                }
                            });
                            delete touchInstances[touch.id];
                        })

                        if(Object.values(touchInstances).length === 0) {
                            always_pluck = false;
                        }
                    }
                    if(event.type === 'touchmove' || event.type === 'mousemove') {

                        Object.values(touchInstances).filter(ti => ti.x && ti.y).forEach(touch => {
                            const { x, y } = touch;
                            const prev_cursor = touch.prevX && touch.prevY ? { x: touch.prevX, y: touch.prevY } : undefined;
                            if(prev_cursor) {
                                let distance = Math.sqrt(Math.pow(x - prev_cursor.x, 2) + Math.pow(y - prev_cursor.y, 2));
                                if(distance > 5) {
                                    let slices = Math.floor(distance / 5);
                                    for(let i=1; i<=slices; i++) {
                                        const interpolated_touch = {
                                            ...touch,
                                            x: prev_cursor.x + i*(x - prev_cursor.x)/slices,
                                            y: prev_cursor.y + i*(y - prev_cursor.y)/slices
                                        };
                                        cursor_move_handler(interpolated_touch);
                                    }
                                }
                            }
                            cursor_move_handler(touch);
                        })
                    }

                }

                ['touchstart', 'touchmove', 'touchend', 'mousedown', 'mousemove', 'mouseup'].forEach(eventName => {
                    canvas.addEventListener(eventName, handleClickOrTouchEvents, { passive: false });
                });

            });

            

        </script>
    </head>
    <body>
        <div class='container'>
            <div class='info'>The same simulation is used to calculate audio &amp; visuals. Plucking at different parts of the string produces different sounds, just like on a guitar.<br />Click or drag strings to play</div>
            <div id='draw'> </div>
            <div id="buttons">
                <div>
                    <div class='button' id='draw-mode-button'>Start</div>
                </div>
            </div>
        </div>
    </body>
</html>

